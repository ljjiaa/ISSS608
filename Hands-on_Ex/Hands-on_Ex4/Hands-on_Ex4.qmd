---
title: "Hands-on Exercise 4"
subtitle: "Fundamentals of Visual Analytics"
date: January 31, 2024
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  warning: false
  toc: true
format: 
  html:
    code-fold: true
editor: visual
---

[Summary]{style="font-size: 20px; font-weight: bold;"}

This hands-on exercise consists of **4 main sections**, namely:

1.  [Visualising Distribution](#Section1)\
2.  [Visual Statistical Analysis](#Section2)
3.  [Visualising Uncertainty](#Section3)
4.  [Funnel Plots for Fair Comparisons](#Section4)

## Visualising Distribution {#Section1}

In previous chapter, we learn to create following statistical graphics using ggplot2:
- histogram, probability density curve (pdf), boxplot, notch plot and violin plot 

In this chapter, two relatively new statistical graphic methods are introduced, namely:
(i) ridgeline plot
(ii) raincloud plot by using ggplot2 and its extensions.

### Loading R packages

For the purpose of this exercise, the following R packages will be used, they are:

- tidyverse - a family of R packages for data science process,
- ggridges - a ggplot2 extension specially designed for plotting ridgeline plots, and
- ggdist - visualising distribution and uncertainty.

```{r}
pacman::p_load(ggdist, ggridges, ggthemes,
               colorspace, tidyverse)
```

### Importing data

For the purpose of this exercise, Exam_data.csv will be used.

```{r}
exam <- read_csv("data/Exam_data.csv")
```

### Ridgeline Plot

Using Ridgeline plot (aka Joyplot), distribution of a numeric value for several groups can be represented using histograms or density plots, all aligned to the same horizontal scale and presented with a slight overlap.

Ridgeline plots works well when:
- the number of group to represent is medium to high as it allows us to use space more efficiently
- there is more than 5 groups (distribution plots is probably better for less than 5 groups)
- there is a clear pattern in the result, like if there is an obvious ranking in groups to avoid overlapping

There are several ways to plot ridgeline plot with R. In this section, you will learn how to plot ridgeline plot by using ggridges package.

ggridges package provides two main geom to plot gridgeline plots, they are: 
- `geom_ridgeline()` - takes height values directly to draw the ridgelines
- `geom_density_ridges()` - first estimates data densities and then draws those using ridgelines

Following are examples of plot using `geom_density_ridges()`:

(i) Basic plot
(ii) Varying fill colors using `geom_density_ridges_gradient()` (or `geom_ridgeline_gradient()`)
(iii) Mapping the probabilities directly onto colour using `stat(ecdf)`
(iv) Adding quantile lines using `stat(quantile)`
(v) Highlighting specific quantile - 2.5% and 97.5% 



::: panel-tabset
#### i

```{r}
ggplot(exam, 
       aes(x = ENGLISH, 
           y = CLASS)) +
  geom_density_ridges(
    scale = 3,
    rel_min_height = 0.01,
    bandwidth = 3.4,
    fill = lighten("#7097BB", .3),
    color = "white"
  ) +
  scale_x_continuous(
    name = "English grades",
    expand = c(0, 0)
    ) +
  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) +
  theme_ridges()
```

#### ii
```{r}
ggplot(exam, 
       aes(x = ENGLISH, 
           y = CLASS,
           fill = stat(x))) +
  geom_density_ridges_gradient(
    scale = 3,
    rel_min_height = 0.01) +
  scale_fill_viridis_c(name = "Temp. [F]",
                       option = "C") +
  scale_x_continuous(
    name = "English grades",
    expand = c(0, 0)
  ) +
  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) +
  theme_ridges()
```

#### iii
```{r}
ggplot(exam,
       aes(x = ENGLISH, 
           y = CLASS, 
           fill = 0.5 - abs(0.5-stat(ecdf)))) +
  stat_density_ridges(geom = "density_ridges_gradient", 
                      calc_ecdf = TRUE) +
  scale_fill_viridis_c(name = "Tail probability",
                       direction = -1) +
  theme_ridges()
```

#### iv
```{r}
ggplot(exam,
       aes(x = ENGLISH, 
           y = CLASS, 
           fill = factor(stat(quantile))
           )) +
  stat_density_ridges(
    geom = "density_ridges_gradient",
    calc_ecdf = TRUE, 
    quantiles = 4,
    quantile_lines = TRUE) +
  scale_fill_viridis_d(name = "Quartiles") +
  theme_ridges()
```

#### v
```{r}
ggplot(exam,
       aes(x = ENGLISH, 
           y = CLASS, 
           fill = factor(stat(quantile))
           )) +
  stat_density_ridges(
    geom = "density_ridges_gradient",
    calc_ecdf = TRUE, 
    quantiles = c(0.025, 0.975)
    ) +
  scale_fill_manual(
    name = "Probability",
    values = c("#FF0000A0", "#A0A0A0A0", "#0000FFA0"),
    labels = c("(0, 0.025]", "(0.025, 0.975]", "(0.975, 1]")
  ) +
  theme_ridges()
```

:::



### Raincloud Plot

Raincloud Plot produces a half-density to a distribution plot which enhances the traditional box-plot by highlighting multiple modalities (an indicator that groups may exist). 

In this section, a raincloud plot visualising the distribution of English score by race will be created by using functions provided by **ggdist** and ggplot2 packages.

(i) Plotting a Half Eye graph by using `stat_halfeye()`
(ii) Adding the boxplot with `geom_boxplot()`
(iii) Adding the Dot Plots with `stat_dots()`
(iv) Flipping it horizontally using `coord_flip()`

Following are examples of raincloud plot and the modification:

::: panel-tabset
#### i
```{r}
ggplot(exam, 
       aes(x = RACE, 
           y = ENGLISH)) +
  stat_halfeye(adjust = 0.5,
               justification = -0.2,
               .width = 0,
               point_colour = NA,
               fill = "lightblue") +
  theme_minimal()
```
::: {.codebox .code data-latex="code"}
**Things to learn from the code chunk above**

slab interval is removed by setting .width = 0 and point_colour = NA.
:::

#### ii
```{r}
ggplot(exam, 
       aes(x = RACE, 
           y = ENGLISH)) +
  stat_halfeye(adjust = 0.5,
               justification = -0.15,
               .width = 0,
               point_colour = NA,
               fill = "lightblue") +
  geom_boxplot(width = .1,
               outlier.shape = NA) +
  theme_minimal()
```

#### iii 
```{r}
ggplot(exam, 
       aes(x = RACE, 
           y = ENGLISH)) +
  stat_halfeye(adjust = 0.5,
               justification = -0.15,
               .width = 0,
               point_colour = NA,
               fill = "lightblue") +
  geom_boxplot(width = .1,
               outlier.shape = NA) +
  stat_dots(side = "left", 
            justification = 1.1, 
            binwidth = .5,
            dotsize = 2) +
  theme_minimal() 
```

#### iv
```{r}
ggplot(exam, 
       aes(x = RACE, 
           y = ENGLISH)) +
  stat_halfeye(adjust = 0.5,
               justification = -0.15,
               .width = 0,
               point_colour = NA,
               fill = "lightblue") +
  geom_boxplot(width = .1,
               outlier.shape = NA) +
  stat_dots(side = "left", 
            justification = 1.1, 
            binwidth = .5,
            dotsize = 1.5,
            fill = "grey70",
            color = "grey70") +          # dotsize is adjusted
  coord_flip() +
  theme_minimal()
```


:::

## Visual Statistical Analysis {#Section2}

- ggstatsplot is an extension of ggplot2 package for creating graphics with details from statistical tests included in the information-rich plots themselves.
  - To provide alternative statistical inference methods by default.
  - To follow best practices for statistical reporting. For all statistical tests reported in the plots, the default template abides by the APA gold standard for statistical reporting. For example, here are results from a robust t-test:

### ggstatsplot 

#### Loading R packages
In this exercise, ggstatsplot and tidyverse will be used.

```{r}
pacman::p_load(ggstatsplot, tidyverse)
```

#### Importing data

For the purpose of this exercise, Exam_data.csv will be used. The following code is used to import Exam_data.csv

```{r}
exam <- read_csv("data/Exam_data.csv")
```


#### Statistical Tests

Following are the graphics with details from various statistical tests:

(i) One-sample test: `gghistostats()` 
(ii) Two-sample mean test: `ggbetweenstats()`
(iii) Two-sample mean test: `ggbetweenstats()`
(iv) Significant Test of Correlation: `ggscatterstats()`
(v) Significant Test of Association (Depedence) : `ggbarstats()` 

::: panel-tabset
#### i
```{r}
set.seed(1234)

gghistostats(
  data = exam,
  x = ENGLISH,
  type = "bayes",
  test.value = 60,
  xlab = "English scores"
)
```

#### ii
```{r}
ggbetweenstats(
  data = exam,
  x = GENDER, 
  y = MATHS,
  type = "np",
  messages = FALSE
)
```


#### iii
```{r}
ggbetweenstats(
  data = exam,
  x = RACE, 
  y = ENGLISH,
  type = "p",
  mean.ci = TRUE, 
  pairwise.comparisons = TRUE, 
  pairwise.display = "s",
  p.adjust.method = "fdr",
  messages = FALSE
)
```

#### iv
```{r}
ggscatterstats(
  data = exam,
  x = MATHS,
  y = ENGLISH,
  marginal = FALSE,
  )
```

#### v

In the code chunk below, the Maths scores is binned into a 4-class variable by using `cut()`.
```{r}
exam1 <- exam %>% 
  mutate(MATHS_bins = 
           cut(MATHS, 
               breaks = c(0,60,75,85,100)))
```

In this code chunk below `ggbarstats()` is used to build a visual for Significant Test of Association
```{r}
ggbarstats(exam1, 
           x = MATHS_bins, 
           y = GENDER)
```

:::

#### Unpacking the Bayes Factor
- A Bayes factor is the ratio of the likelihood of one particular hypothesis to the likelihood of another. It can be interpreted as a measure of the strength of evidence in favor of one theory among two competing theories.

- That’s because the Bayes factor gives us a way to evaluate the data in favor of a null hypothesis, and to use external information to do so. It tells us what the weight of the evidence is in favor of a given hypothesis.

- When we are comparing two hypotheses, H1 (the alternate hypothesis) and H0 (the null hypothesis), the Bayes Factor is often written as B10.

- The Schwarz criterion is one of the easiest ways to calculate rough approximation of the Bayes Factor.

- A Bayes Factor can be any positive number. One of the most common interpretations is this one—first proposed by Harold Jeffereys (1961) and slightly modified by [Lee and Wagenmakers](https://www-tandfonline-com.libproxy.smu.edu.sg/doi/pdf/10.1080/00031305.1999.10474443?needAccess=true) in 2013

### Models

In this section, we visualise model diagnostic and model parameters by using parameters package.

- Toyota Corolla case study will be used. The purpose of study is to build a model to discover factors affecting prices of used-cars by taking into consideration a set of explanatory variables.

#### Loading R packages

```{r}
pacman::p_load(readxl, performance, parameters, see)
```

#### Importing data
In the code chunk below, `read_xls()` of readxl package is used to import the data worksheet of ToyotaCorolla.xls workbook into R.
```{r}
car_resale <- read_xls("data/ToyotaCorolla.xls", 
                       "data")
car_resale
```


#### Multiple Regression Model using lm()
The code chunk below is used to calibrate a multiple linear regression model by using `lm()` of Base Stats of R.

```{r}
model <- lm(Price ~ Age_08_04 + Mfg_Year + KM + 
              Weight + Guarantee_Period, data = car_resale)
model
```


#### Model Diagnostic

(i) checking for multicolinearity using `check_collinearity()`
(ii) checking normality assumption using `check_normality()`
(iii) Check model for homogeneity of variances using `check_heteroscedasticity()`
(iv) Complete check using `check_model()`

::: panel-tabset

#### i

```{r}
check_collinearity(model)
```
```{r}
check_c <- check_collinearity(model)
plot(check_c)
```

#### ii
```{r}
model1 <- lm(Price ~ Age_08_04 + KM + 
              Weight + Guarantee_Period, data = car_resale)
```

```{r}
check_n <- check_normality(model1)
```

```{r}
plot(check_n)
```

#### iii

```{r}
check_h <- check_heteroscedasticity(model1)
```

```{r}
plot(check_h)
```


#### iv
```{r}
check_model(model1)
```


:::


#### Visualising Regression Parameters

There are two methods to visualise regression parameters:
(i) See method using `plot()` and `parameters()`
(ii) using `ggcoefstats()` 

Examples of the plots are as follows:

::: panel-tabset

#### i
```{r}
plot(parameters(model1))
```

#### ii
```{r}
ggcoefstats(model1, 
            output = "plot")
```

:::

## Visualising Uncertainty {#Section3}

### Installing and loading the packages
```{r}
devtools::install_github("wilkelab/ungeviz")
```

```{r}
pacman::p_load(ungeviz, plotly, crosstalk,
               DT, ggdist, ggridges,
               colorspace, gganimate, tidyverse)
```



### Importing data

```{r}
exam <- read_csv("data/Exam_data.csv")
```


### ggplot2 methods

```{r}
my_sum <- exam %>%
  group_by(RACE) %>%
  summarise(
    n=n(),
    mean=mean(MATHS),
    sd=sd(MATHS)
    ) %>%
  mutate(se=sd/sqrt(n-1))
```

```{r}
knitr::kable(head(my_sum), format = 'html')
```

(i) Plotting standard error bars of point estimates
(ii) Plotting confidence interval of point estimates
(iii) Visualizing the uncertainty of point estimates with interactive error bars

::: panel-tabset
#### i
```{r}
ggplot(my_sum) +
  geom_errorbar(
    aes(x=RACE, 
        ymin=mean-se, 
        ymax=mean+se), 
    width=0.2, 
    colour="black", 
    alpha=0.9, 
    size=0.5) +
  geom_point(aes
           (x=RACE, 
            y=mean), 
           stat="identity", 
           color="red",
           size = 1.5,
           alpha=1) +
  ggtitle("Standard error of mean maths score by rac")
```

#### ii
```{r}
ggplot(my_sum) +
  geom_errorbar(
    aes(x=reorder(RACE, -mean), 
        ymin=mean-1.96*se, 
        ymax=mean+1.96*se), 
    width=0.2, 
    colour="black", 
    alpha=0.9, 
    size=0.5) +
  geom_point(aes
           (x=RACE, 
            y=mean), 
           stat="identity", 
           color="red",
           size = 1.5,
           alpha=1) +
  labs(x = "Maths score",
       title = "95% confidence interval of mean maths score by race")
```


#### iii

```{r}
shared_df = SharedData$new(my_sum)

bscols(widths = c(4,8),
       ggplotly((ggplot(shared_df) +
                   geom_errorbar(aes(
                     x=reorder(RACE, -mean),
                     ymin=mean-2.58*se, 
                     ymax=mean+2.58*se), 
                     width=0.2, 
                     colour="black", 
                     alpha=0.9, 
                     size=0.5) +
                   geom_point(aes(
                     x=RACE, 
                     y=mean, 
                     text = paste("Race:", `RACE`, 
                                  "<br>N:", `n`,
                                  "<br>Avg. Scores:", round(mean, digits = 2),
                                  "<br>95% CI:[", 
                                  round((mean-2.58*se), digits = 2), ",",
                                  round((mean+2.58*se), digits = 2),"]")),
                     stat="identity", 
                     color="red", 
                     size = 1.5, 
                     alpha=1) + 
                   xlab("Race") + 
                   ylab("Average Scores") + 
                   theme_minimal() + 
                   theme(axis.text.x = element_text(
                     angle = 45, vjust = 0.5, hjust=1)) +
                   ggtitle("99% Confidence interval of average /<br>maths scores by race")), 
                tooltip = "text"), 
       DT::datatable(shared_df, 
                     rownames = FALSE, 
                     class="compact", 
                     width="100%", 
                     options = list(pageLength = 10,
                                    scrollX=T), 
                     colnames = c("No. of pupils", 
                                  "Avg Scores",
                                  "Std Dev",
                                  "Std Error")) %>%
         formatRound(columns=c('mean', 'sd', 'se'),
                     digits=2))
```


:::


### ggdist methods


(i) displaying distribution of maths scores by race using `stat_pointinterval()`
(ii) Showing median
(iii) showing 95% and 99% confidence intervals
(iv) displaying distribution of maths scores by race using `stat_gradientinterval()`

::: panel-tabset

#### i
```{r}
exam %>%
  ggplot(aes(x = RACE, 
             y = MATHS)) +
  stat_pointinterval() +
  labs(
    title = "Visualising confidence intervals of mean math score",
    subtitle = "Mean Point + Multiple-interval plot")
```

#### ii
```{r}
exam %>%
  ggplot(aes(x = RACE, y = MATHS)) +
  stat_pointinterval(.width = 0.95,
  .point = median,
  .interval = qi) +
  labs(
    title = "Visualising confidence intervals of median math score",
    subtitle = "Median Point + Multiple-interval plot")
```


#### iii
```{r}
exam %>%
  ggplot(aes(x = RACE, 
             y = MATHS)) +
  stat_pointinterval(
    show.legend = FALSE) +   
  labs(
    title = "Visualising confidence intervals of mean math score",
    subtitle = "Mean Point + Multiple-interval plot")
```


#### iv
```{r}
exam %>%
  ggplot(aes(x = RACE, 
             y = MATHS)) +
  stat_gradientinterval(   
    fill = "pink",      
    show.legend = TRUE     
  ) +                        
  labs(
    title = "Visualising confidence intervals of mean math score",
    subtitle = "Gradient + interval plot")
```

:::


### Hypothetical Outcome Plots (HOPs)


```{r}
devtools::install_github("wilkelab/ungeviz")
```
```{r}
library(ungeviz)
```

```{r}
ggplot(data = exam, 
       (aes(x = factor(RACE), 
            y = MATHS))) +
  geom_point(position = position_jitter(
    height = 0.3, 
    width = 0.05), 
    size = 0.4, 
    color = "#0072B2", 
    alpha = 1/2) +
  geom_hpline(data = sampler(25, 
                             group = RACE), 
              height = 0.6, 
              color = "#D55E00") +
  theme_bw() + 
  transition_states(.draw, 1, 3)          # `.draw` is a generated column indicating the sample draw
```


## Funnel Plots for Fair Comparisons {#Section4}

### Installing and Launching R Packages
```{r}
pacman::p_load(tidyverse, FunnelPlotR, plotly, knitr)
```

### Importing Data
```{r}
covid19 <- read_csv("data/COVID-19_DKI_Jakarta.csv") %>%
  mutate_if(is.character, as.factor)
```


### FunnelPlotR methods

::: panel-tabset
#### basic
```{r}
funnel_plot(
  numerator = covid19$Positive,
  denominator = covid19$Death,
  group = covid19$`Sub-district`
)
```

#### makeover 1
```{r}
funnel_plot(
  numerator = covid19$Death,
  denominator = covid19$Positive,
  group = covid19$`Sub-district`,
  data_type = "PR",     #<<
  xrange = c(0, 6500),  #<<
  yrange = c(0, 0.05)   #<<
)
```

#### makeover 2
```{r}
funnel_plot(
  numerator = covid19$Death,
  denominator = covid19$Positive,
  group = covid19$`Sub-district`,
  data_type = "PR",   
  xrange = c(0, 6500),  
  yrange = c(0, 0.05),
  label = NA,
  title = "Cumulative COVID-19 Fatality Rate by Cumulative Total Number of COVID-19 Positive Cases", #<<           
  x_label = "Cumulative COVID-19 Positive Cases", #<<
  y_label = "Cumulative Fatality Rate"  #<<
)
```

:::

### ggplot2 methods

#### Computing the basic derived fields
```{r}
df <- covid19 %>%
  mutate(rate = Death / Positive) %>%
  mutate(rate.se = sqrt((rate*(1-rate)) / (Positive))) %>%
  filter(rate > 0)
```


```{r}
fit.mean <- weighted.mean(df$rate, 1/df$rate.se^2)
```

#### Calculate lower and upper limits for 95% and 99.9% CI

```{r}
number.seq <- seq(1, max(df$Positive), 1)
number.ll95 <- fit.mean - 1.96 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) 
number.ul95 <- fit.mean + 1.96 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) 
number.ll999 <- fit.mean - 3.29 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) 
number.ul999 <- fit.mean + 3.29 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) 
dfCI <- data.frame(number.ll95, number.ul95, number.ll999, 
                   number.ul999, number.seq, fit.mean)
```


::: panel-tabset
#### Static
```{r}
p <- ggplot(df, aes(x = Positive, y = rate)) +
  geom_point(aes(label=`Sub-district`), 
             alpha=0.4) +
  geom_line(data = dfCI, 
            aes(x = number.seq, 
                y = number.ll95), 
            size = 0.4, 
            colour = "grey40", 
            linetype = "dashed") +
  geom_line(data = dfCI, 
            aes(x = number.seq, 
                y = number.ul95), 
            size = 0.4, 
            colour = "grey40", 
            linetype = "dashed") +
  geom_line(data = dfCI, 
            aes(x = number.seq, 
                y = number.ll999), 
            size = 0.4, 
            colour = "grey40") +
  geom_line(data = dfCI, 
            aes(x = number.seq, 
                y = number.ul999), 
            size = 0.4, 
            colour = "grey40") +
  geom_hline(data = dfCI, 
             aes(yintercept = fit.mean), 
             size = 0.4, 
             colour = "grey40") +
  coord_cartesian(ylim=c(0,0.05)) +
  annotate("text", x = 1, y = -0.13, label = "95%", size = 3, colour = "grey40") + 
  annotate("text", x = 4.5, y = -0.18, label = "99%", size = 3, colour = "grey40") + 
  ggtitle("Cumulative Fatality Rate by Cumulative Number of COVID-19 Cases") +
  xlab("Cumulative Number of COVID-19 Cases") + 
  ylab("Cumulative Fatality Rate") +
  theme_light() +
  theme(plot.title = element_text(size=12),
        legend.position = c(0.91,0.85), 
        legend.title = element_text(size=7),
        legend.text = element_text(size=7),
        legend.background = element_rect(colour = "grey60", linetype = "dotted"),
        legend.key.height = unit(0.3, "cm"))
p
```

#### Interactive 

```{r}
fp_ggplotly <- ggplotly(p,
  tooltip = c("label", 
              "x", 
              "y"))
fp_ggplotly
```

:::

## Reference

-   Kam, T.S.(2023) [Visualising Distribution](https://r4va.netlify.app/chap09)

-   Kam, T.S.(2023) [Visual Statistical Analysis](https://r4va.netlify.app/chap10)

-   Kam, T.S.(2023) [Visualising Uncertainty](https://r4va.netlify.app/chap11)

-   Kam, T.S.(2023) [Funnel Plots for Fair Comparisons](https://r4va.netlify.app/chap12)