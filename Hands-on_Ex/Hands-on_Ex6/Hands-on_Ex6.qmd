---
title: "Hands-on Exercise 6"
subtitle: "Visualising and Analysing Time-oriented Data"
date: February 20, 2024
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  warning: false
  toc: true
format: 
  html:
    code-fold: false
---

## Overview

In this hands-on exercise, we learn to create the followings data visualisation by using R packages:

-   [calender heatmap by using ggplot2 functions](#Section1)\
-   [cycle plot by using ggplot2 function](#Section2)
-   [slopegraph](#Section3)
-   [horizon chart](#Section4)

## Installing and Launching R Packages

The code chunks below are used to install and load the packages in R.

```{r}
pacman::p_load(scales, viridis, lubridate, ggthemes, gridExtra, 
               readxl, knitr, data.table, CGPfunctions, ggHoriPlot, tidyverse)
```

## Plotting Calendar Heatmap {#Section1}

By the end of this section, we will be able to plot a calender heatmap by using ggplot2 functions and its extension. On top of that, we will learn to derive specific date and time related field by using base R and lubridate packages.

### Importing the data

For the purpose of this hands-on exercise, *eventlog.csv* file will be used. This data file consists of 199,999 rows of time-series cyber attack records by country.

First, the code chunk below is used to import *eventlog.csv* file into R environment and called the data frame as *attacks*.

```{r}
#| message: TRUE
attacks <- read_csv("data/eventlog.csv")
```

### Examining the data structure

`kable()` can be used to review the structure of the imported data frame.

```{r}
kable(head(attacks))
```

There are three columns, namely ***timestamp***, ***source_country*** and ***tz***.

-   *timestamp* field stores date-time values in POSIXct format.
-   *source_country* field stores the source of the attack. It is in *ISO 3166-1 alpha-2* country code.\
-   *tz* field stores time zone of the source IP address.

### Data Preparation

**Step 1**: Deriving *weekday* and *hour of day* fields

Before we can plot the calender heatmap, two new fields namely *wkday* and *hour* need to be derived.

```{r}
make_hr_wkday <- function(ts, sc, tz) {
  real_times <- ymd_hms(ts, 
                        tz = tz[1], 
                        quiet = TRUE)
  dt <- data.table(source_country = sc,
                   wkday = weekdays(real_times),
                   hour = hour(real_times))
  return(dt)
  }
```

::: {.codebox .code data-latex="code"}
-   [`ymd_hms()`](https://lubridate.tidyverse.org/reference/ymd_hms.html) and [`hour()`](https://lubridate.tidyverse.org/reference/hour.html) are from [**lubridate**](https://lubridate.tidyverse.org/) package, and
-   [`weekdays()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/weekdays) is a **base** R function.
:::

**Step 2**: Deriving the attacks tibble data frame

```{r}
wkday_levels <- c('Saturday', 'Friday', 
                  'Thursday', 'Wednesday', 
                  'Tuesday', 'Monday', 
                  'Sunday')

attacks <- attacks %>%
  group_by(tz) %>%
  do(make_hr_wkday(.$timestamp, 
                   .$source_country, 
                   .$tz)) %>% 
  ungroup() %>% 
  mutate(wkday = factor(
    wkday, levels = wkday_levels),
    hour  = factor(
      hour, levels = 0:23))
```

::: {.codebox .code data-latex="code"}
Beside extracting the necessary data into *attacks* data frame, `mutate()` of **dplyr** package is used to convert *wkday* and *hour* fields into **factor** so they'll be ordered when plotting
:::

Table below shows the tidy tibble table after processing.

```{r}
kable(head(attacks))
```

### Plotting the Calendar Heatmaps

Before plotting the heatmaps, the following code is used to count the total number of attacks on a particular hour and weekday:

```{r}
grouped <- attacks %>% 
  count(wkday, hour) %>% 
  ungroup() %>%
  na.omit()
```

Let us examine the data frame.

```{r}
kable(head(grouped))
```

```{r}
ggplot(grouped, 
       aes(hour, 
           wkday, 
           fill = n)) + 
geom_tile(color = "white", 
          linewidth = 0.1,
          linetype = "dashed") + 
theme_tufte(base_family = "Helvetica") +
coord_equal() +
scale_fill_gradient(name = "# of attacks",
                    low = "beige",
                    high = "chocolate4") +
labs(x = NULL, 
     y = NULL, 
     title = "Attacks by weekday and time of day") +
theme(axis.ticks = element_blank(),
      plot.title = element_text(hjust = 0.5),
      legend.title = element_text(size = 8),
      legend.text = element_text(size = 6) )
```

::: {.codebox .code data-latex="code"}
**Things to learn from the code chunk**

-   a tibble data table called *grouped* is derived by aggregating the attack by *wkday* and *hour* fields.
-   a new field called *n* is derived by using `group_by()` and `count()` functions.
-   `na.omit()` is used to exclude missing value.
-   `geom_tile()` is used to plot tiles (grids) at each x and y position. `color` and `size` arguments are used to specify the border color and line size of the tiles.
-   [`theme_tufte()`](https://jrnold.github.io/ggthemes/reference/theme_tufte.html) of [**ggthemes**](https://jrnold.github.io/ggthemes/reference/index.html) package is used to remove unnecessary chart junk. To learn which visual components of default ggplot2 have been excluded, you are encouraged to comment out this line to examine the default plot.
-   `coord_equal()` is used to ensure the plot will have an aspect ratio of 1:1.
-   `scale_fill_gradient()` function is used to creates a two colour gradient (low-high).
:::

### Plotting Multiple Calendar Heatmaps

**Challenge:** Building multiple heatmaps for the top four countries with the highest number of attacks.

**Step 1**: Deriving attack by country object

In order to identify the top 4 countries with the highest number of attacks, refer to the followings steps:

-   count the number of attacks by country,
-   calculate the percent of attackes by country, and
-   save the results in a tibble data frame.

```{r}
attacks_by_country <- count(
  attacks, source_country) %>%
  mutate(percent = percent(n/sum(n))) %>%
  arrange(desc(n))
```

```{r}
kable(head(attacks_by_country))
```

**Step 2**: Preparing the tidy data frame

In this step, attack records of the top 4 countries from *attacks* data frame are extracted and saved in a new tibble data frame (i.e. *top4_attacks*).

```{r}
top4 <- attacks_by_country$source_country[1:4]
top4_attacks <- attacks %>%
  filter(source_country %in% top4) %>%
  count(source_country, wkday, hour) %>%
  ungroup() %>%
  mutate(source_country = factor(
    source_country, levels = top4)) %>%
  na.omit()
```

```{r}
kable(head(top4_attacks))
```

**Step 3**: Plotting the Multiple Calender Heatmap by using ggplot2 package.

```{r fig.width = 12}
ggplot(top4_attacks, 
       aes(hour, 
           wkday, 
           fill = n)) + 
  geom_tile(color = "white", 
          size = 0.1) + 
  theme_tufte(base_family = "Helvetica") + 
  coord_equal() +
  scale_fill_gradient(name = "# of attacks",
                    low = "beige", 
                    high = "chocolate4") +
  facet_wrap(~source_country, ncol = 2) +
  labs(x = NULL, 
       y = NULL, 
     title = "Attacks on top 4 countries by weekday and time of day") +
  theme(axis.ticks = element_blank(),
        axis.text.x = element_text(size = 7),
        plot.title = element_text(hjust = 0.5),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 6) )
```

## Plotting Cycle Plot {#Section2}

In this section, we will learn how to plot a cycle plot showing the time-series patterns and trend of visitor arrivals from Vietnam programmatically by using ggplot2 functions.

### Data Import

For the purpose of this hands-on exercise, *arrivals_by_air.xlsx* will be used.

The code chunk below imports *arrivals_by_air.xlsx* by using `read_excel()` of **readxl** package and save it as a tibble data frame called *air*.

```{r}
#| message: TRUE
air <- read_excel("data/arrivals_by_air.xlsx")
```

After importing, we examine the first 5 row of the data by using `head()`.

```{r}
head(air,5)
```

### Data Preparation

**Step 1**: Deriving month and year fields

Next, two new fields called *month* and *year* are derived from *Month-Year* field.

```{r}
air$month <- factor(month(air$`Month-Year`), 
                    levels=1:12, 
                    labels=month.abb, 
                    ordered=TRUE) 
air$year <- year(ymd(air$`Month-Year`))
```

**Step 2**: Extracting the target country

Next, the code chunk below is use to extract data for the target country (i.e. Vietnam) from 2010 onwards.

```{r}
Vietnam <- air %>% 
  select(`Vietnam`, 
         month, 
         year) %>%
  filter(year >= 2010)
```

**Step 3**: Computing year average arrivals by month

The code chunk below uses `group_by()` and `summarise()` of **dplyr** to compute year average arrivals by month.

```{r}
hline.data <- Vietnam %>% 
  group_by(month) %>%
  summarise(avgvalue = mean(`Vietnam`))
```

### Plotting the cycle plot

The code chunk below is used to plot the cycle plot.

```{r}
#| fig-width: 10
#| fig-height: 4
ggplot() + 
  geom_line(data=Vietnam,
            aes(x=year, 
                y=`Vietnam`, 
                group=month), 
            colour="black") +
  geom_hline(aes(yintercept=avgvalue), 
             data=hline.data, 
             linetype=6, 
             colour="red", 
             size=0.5) + 
  facet_grid(~month) +
  labs(axis.text.x = element_blank(),
       title = "Visitor arrivals from Vietnam by air, Jan 2010-Dec 2019") +
  xlab("") +
  ylab("No. of Visitors") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        panel.background = element_rect(fill="white", color= "grey50"),
        panel.grid = element_line(color= "grey80", linetype = "dashed", linewidth = 0.1),
        strip.background = element_rect(fill = "grey50"),
        strip.text = element_text(colour = "white"))
```

## Plotting Slopegraph {#Section3}

In this section we will learn how to plot a [slopegraph](https://www.storytellingwithdata.com/blog/2020/7/27/what-is-a-slopegraph) by using **CGPfunctions**.Refer to [Using newggslopegraph](https://cran.r-project.org/web/packages/CGPfunctions/vignettes/Using-newggslopegraph.html) to learn more about the function and read more about `newggslopegraph()` and [arguments](https://www.rdocumentation.org/packages/CGPfunctions/versions/0.6.3/topics/newggslopegraph).

### Data Import

Import the rice data set into R environment by using the code chunk below.

```{r}
#| message: TRUE
rice <- read_csv("data/rice.csv")
```

```{r}
kable(head(rice))
```

### Plotting the slopegraph

The following code chunk will be used to plot a slopegraph.

::: panel-tabset
#### Default

```{r}
#| fig-height: 8
rice %>% 
  mutate(Year = as.factor(Year)) %>%
  filter(Year %in% c(1970, 1980, 1990)) %>%
  newggslopegraph(Year, Yield, Country,
                Title = "Rice Yield of Top 11 Asian Counties",
                SubTitle = "1970-1990",
                Caption = NULL)
```

#### Changing line colour

```{r}
#| fig-height: 8
rice %>% 
  mutate(Year = as.factor(Year)) %>%
  filter(Year %in% c(1970, 1980, 1990)) %>%
  newggslopegraph(Year, Yield, Country,
                Title = "Rice Yield of Top 11 Asian Counties",
                SubTitle = "1970-1990",
                Caption = NULL,
                LineColor = "grey",
                LineThickness = 0.8)
```

#### Highlighting line colour

```{r}
#| fig-height: 8
rice %>% 
  mutate(Year = as.factor(Year)) %>%
  filter(Year %in% c(1970, 1980, 1990)) %>%
  newggslopegraph(Year, Yield, Country,
                Title = "Rice Yield of Top 11 Asian Counties",
                SubTitle = "1970-1980",
                Caption = NULL,
                LineColor = c("Malaysia" = "gold", "Thailand" = "blue"),
                LineThickness = 0.8)
```
:::

::: {.codebox .code data-latex="code"}
**Thing to learn from the code chunk above**

-   For effective data visualisation design, `as.factor()` is used convert the value type of *Year* field from numeric to factor.
-   By default, the line is colourful; after highlighting the specific line using `LineColor`, the other line will turn grey.
:::

## Plotting horizon chart {#Section4}

A horizon graph is an analytical graphical method specially designed for visualising large numbers of time-series. It aims to overcome the issue of visualising highly overlapping time-series as shown in the figure below.

A horizon graph essentially an area chart that has been split into slices and the slices then layered on top of one another with the areas representing the highest (absolute) values on top. Each slice has a greater intensity of colour based on the absolute value it represents.

In this section, we will learn how to plot a [horizon graph](http://www.perceptualedge.com/articles/visual_business_intelligence/time_on_the_horizon.pdf) by using [**ggHoriPlot**](https://rivasiker.github.io/ggHoriPlot/index.html) package.Refer to this [link](https://rivasiker.github.io/ggHoriPlot/articles/ggHoriPlot.html) to learn more about the functions of ggHoriPlot package. Next, read [`geom_horizon()`](https://rivasiker.github.io/ggHoriPlot/reference/geom_horizon.html) to learn more about the usage of its arguments. :::

### Data Import

For the purpose of this hands-on exercise, [Average Retail Prices Of Selected Consumer Items](https://tablebuilder.singstat.gov.sg/table/TS/M212891) will be used.

Use the code chunk below to import the AVERP.csv file into R environment.

```{r}
#| message: TRUE
averp <- read_csv("data/AVERP.csv") %>%
  mutate(`Date` = dmy(`Date`))
```

Next, we examine the first 5 row of data table using `head()`

```{r}
head(averp,5)
```

::: {.codebox .code data-latex="code"}
**Thing to learn from the code chunk above**

-   By default, read_csv will import data in Date field as Character data type. [`dmy()`](https://lubridate.tidyverse.org/reference/ymd.html) of [**lubridate**](https://lubridate.tidyverse.org/index.html) package to palse the Date field into appropriate Date data type in R.\
:::

### Plotting the horizon graph

```{r}
#| fig-width: 10
#| fig-height: 10
averp %>% 
  filter(Date >= "2018-01-01") %>%
  ggplot() +
  geom_horizon(aes(x = Date, y=Values), 
               origin = "midpoint", 
               horizonscale = 6)+
  facet_grid(`Consumer Items`~.) +
    theme_few() +
  scale_fill_hcl(palette = 'YlOrBr') +      #run colorspace::hcl_palettes() to list avai palettes
  theme(panel.spacing.y=unit(0, "lines"), 
        strip.text.y = element_text(
    size = 6, angle = 0, hjust = 0),
    legend.position = 'none',
    axis.text.y = element_blank(),
    axis.text.x = element_text(size=8),
    axis.title.y = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks.y = element_blank(),
    panel.border = element_blank()
    ) +
    scale_x_date(expand=c(0,0), 
                 date_breaks = "6 month", 
                 date_labels = "%b%y") +
  ggtitle('Average Retail Prices of Selected Consumer Items (Jan 2018 to Dec 2022)')
```

## Reference

-   Kam, T.S.(2023) [Visualising and Analysing Time-oriented Data](https://r4va.netlify.app/chap17)

-   Kam, T.S.(2023) [Time on the Horizon: ggHoriPlot methods](https://r4va.netlify.app/chap20)
