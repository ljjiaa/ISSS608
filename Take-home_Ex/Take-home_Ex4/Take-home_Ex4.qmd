---
title: "Take-home Exercise 4"
subtitle: "Prototyping Modules for Visual Analytics Shiny Application"
author: "Lim Jia Jia"
date: March 7, 2024
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  warning: false
  toc: true
format: 
  html:
    code-fold: false
---

## Overview

In this take-home exercise, we are required to select one of the module of our proposed Shiny application and complete the following tasks:

-   To evaluate and determine the necessary R packages needed for your Shiny application are supported in R CRAN,
-   To prepare and test the specific R codes can be run and returned the correct output as expected,
-   To determine the parameters and outputs that will be exposed on the Shiny applications, and
-   To select the appropriate Shiny UI components for exposing the parameters determine above.

The module that we are focusing on is the univariate forecasting of the data.

## Loading R packages

First and foremost, we will start by loading the R packages required.

```{r}
pacman::p_load(tidyverse, ggplot2, tsibble, tsibbledata,  
                fable, fabletools, feasts, 
               plotly, DT, fable.prophet)
```

## Data preparation

As this take home exercise serves as analysis of one of the module of the project, the data preparation steps is only performed once to ensure that same data set **(weather_imputed_11stations.rds)** are used across all members. Detailed preparation steps can be found in this [link](https://isss608-airweatheranalytics.netlify.app/code/data_preparation_weather).

### Importing the data

We import the processed data set using `read_rds()`,

```{r}
weather <- read_rds("data/weather_imputed_11stations.rds")
```

```{r}
head(weather)
```

### Convert to tsibble data frame

The dataset comprises daily records of rainfall and temperature gathered from various weather stations across Singapore. Initially, this data is loaded in a 'tibble' format. However, for our forecasting analysis, we will be using [**fable**](https://fable.tidyverts.org/) package, which is part of the [tidyverts](https://tidyverts.org/) ecosystem and requires data in a ['tsibble'](https://tsibble.tidyverts.org/) format. To accommodate this requirement, we will convert our tibble dataframe into a tsibble using the following code.

```{r}
weather_tsbl <- as_tsibble(weather, key = Station, index = Date)
weather_tsbl
```

The list below shows 11 unique stations.

```{r}
Station <- weather_tsbl %>% distinct(Station)

datatable(Station, 
          class= "compact",
          rownames = FALSE,
          width="100%", 
          options = list(pageLength = 12,scrollX=T))
```

::: {.focusbox .focus data-latex="focus"}
**What is tsibble?**

A tsibble consists of a time index, key, and other measured variables in a data-centric format. In tsibble,

-   Index is a variable with inherent ordering from past to present.
-   Key is a set of variables that define observational units over time.
-   Each observation should be uniquely identified by index and key.
-   Each observational unit should be measured at a common interval, if regularly spaced.
:::

## Section 1: Time Series Exploration

In this section, users can interactively explore time series data using a line graph equipped with a time slider. They have the option to select specific stations, variables, and time periods for analysis.

```{r}
# user defined parameter
selected_stations <- c("Ang Mo Kio", "Changi", "Tai Seng") 
variable_temp <- "Minimum Temperature (°C)"
variable_rain <- "Daily Rainfall Total (mm)"
start_date <- "2021-01-01"
end_date <-  "2023-12-31"

```


::: panel-tabset
#### Daily view

```{r}
# Filter data based on period
filtered_period <- weather_tsbl %>%
  filter_index(start_date ~ end_date)

# Filter period-filtered data based on multiple selected stations
filtered_period_mstn <- filtered_period  %>%
  filter(Station %in% selected_stations) 

# Generate the plot based on filtered data
plot_ly(filtered_period_mstn, 
             x = ~Date, 
             y = as.formula(paste0("~`", variable_temp, "`")), 
             type = 'scatter', 
             mode = 'lines', 
             color = ~Station,
             hoverinfo = 'text',
             text = ~paste("<b>Station:</b>", Station,
                           "<br><b>Date:</b>", Date,
                           "<br><b>", variable_temp, ":</b>", filtered_period_mstn[[variable_temp]])) %>%
  layout(title = paste(variable_temp, "by Station"),
         xaxis = list(title = ""),
         yaxis = list(title = "")) %>%

# Display the plot
 layout(xaxis = list(rangeslider = list(type = "date"))) 

```

#### Weekly: avarage Temperature

The code chunk below plot line graph for weekly summarise view of the following variables: "Mean Temperature (°C)", "Minimum Temperature (°C)", "Maximum Temperature (°C)"

```{r}

# Summarise period-filtered temperature data based on weekly average
summarised_temp <- filtered_period %>%
  group_by_key() %>%
  index_by(year_week = ~ yearweek(.)) %>%
  summarise(
    avg_temp = round(mean(.data[[variable_temp]]),2), na.rm = TRUE)

# Filter summarised temperature data based on multiple selected stations
summarised_temp_mstn <- summarised_temp  %>%
  filter(Station %in% selected_stations) 

# Convert the year_week result to the first day of the week for plotting
summarised_temp_mstn <- summarised_temp_mstn %>%
  mutate(week_start_date = floor_date(as.Date(year_week), unit = "week"))

# Generate the plot based on filtered data
plot_ly(summarised_temp_mstn, x = ~week_start_date, y = ~avg_temp,
             type = 'scatter', mode = 'lines', color = ~Station,
             hoverinfo = 'text',
             text = ~paste("<b>Station:</b>", Station, 
                           "<br><b>Week Starting:</b>", week_start_date, 
                           "<br><b>Average", variable_temp, ":</b>", avg_temp)) %>%

  layout(title = paste("Weekly Average", variable_temp, "by Station"),
         xaxis = list(title = ""),
         yaxis = list(title = "")) %>%
  
  # Display the plot
  layout(xaxis = list(rangeslider = list(type = "date"))) 

```

#### Rainfall, weekly total

The code chunk below plot line graph for weekly summarise view of "Daily Rainfall Total (mm)".

```{r}
# Summarise period-filtered rainfall data based on weekly total
summarised_rain <- filtered_period %>%
  group_by_key() %>%
  index_by(year_week = ~ yearweek(.)) %>%
  summarise(
    total_rainfall = sum(.data[[variable_rain]]), na.rm = TRUE)

# Filter summarised rainfall data based on multiple selected stations
summarised_rain_mstn <- summarised_rain  %>%
  filter(Station %in% selected_stations) 

# Convert the year_week result to the first day of the week for plotting
summarised_rain_mstn <- summarised_rain_mstn %>%
  mutate(week_start_date = floor_date(as.Date(year_week), unit = "week"))

# Generate the plot based on filtered data
plot_ly(summarised_rain_mstn, x = ~week_start_date, y = ~total_rainfall,
             type = 'scatter', mode = 'lines', color = ~Station,
             hoverinfo = 'text',
             text = ~paste("<b>Station:</b>", Station, 
                           "<br><b>Week Starting:</b>", week_start_date, 
                           "<br><b>Total rainfall :</b>", total_rainfall, "mm")) %>%

  layout(title = paste("Weekly", variable_rain, "by Station"),
         xaxis = list(title = ""),
         yaxis = list(title = "")) %>% 
  
  # Display the plot
  layout(xaxis = list(rangeslider = list(type = "date"))) 

```
:::






### UI design

![](images/1_Exploration.png)

## Section 2: Time Series Decomposition

This section introduces the STL method, a versatile and robust method that breaks down time series data into trend, seasonality, and remainder components.

STL is an acronym for “Seasonal and Trend decomposition using Loess”, while loess is a method for estimating nonlinear relationships. We will use STL to uncover deeper insights into our data, highlighting its importance in understanding and predicting trends.

Below are the sample plot of STL decomposition using different tuning parameter.

### STL Decomposition analysis.

```{r}
single_station <- "Ang Mo Kio"

filtered_period_sstn <- filtered_period  %>%
  filter(Station %in% single_station) 
```



```{r}
stl_formula_default <- STL(`Mean Temperature (°C)`)

stl_formula_tuned <- STL(`Mean Temperature (°C)`
                         ~ trend(window = 20) +        
                           ~  season(window = 20))
```

::: panel-tabset
#### **Auto STL decomposition plot**
```{r}
stl_default <- filtered_period_sstn %>%
  model(stl_formula_default) %>%
  components() 
stl_default
```

```{r}
stl_default_tibble <- as_tibble(stl_default) %>%
  select(Date, `Mean Temperature (°C)`, trend, season_week, season_year, remainder, season_adjust) %>%
  mutate(trend = round(trend, 2),
         season_adjust = round(season_adjust, 2),
         season_week = round(season_week, 4),
         season_year = round(season_year, 4),
         remainder = round(remainder, 4))

datatable(stl_default_tibble, 
          class= "nowrap", 
          rownames = FALSE, 
          filter = 'top',  # Enables filters at the top of each column
          width="100%", 
          options = list(pageLength = 10, scrollX = TRUE))
```


```{r}
plot_stl_default <- stl_default %>%
  autoplot()

ggplotly(plot_stl_default) %>% layout(width = 700, height = 700, 
                      plot_bgcolor="#edf2f7")
```



#### **Manual STL decomposition plot**


```{r}
stl_tuned <- filtered_period_sstn %>%
  model(stl_formula_tuned) %>%
  components() 
stl_default
```

```{r}
stl_tuned_tibble <- as_tibble(stl_tuned) %>%
  select(Date, `Mean Temperature (°C)`, trend, season_week, season_year, remainder, season_adjust) %>%
  mutate(trend = round(trend, 2),
         season_adjust = round(season_adjust, 2),
         season_week = round(season_week, 4),
         season_year = round(season_year, 4),
         remainder = round(remainder, 4))

datatable(stl_tuned_tibble, 
          class= "nowrap", 
          rownames = FALSE, 
          filter = 'top',  # Enables filters at the top of each column
          width="100%", 
          options = list(pageLength = 10, scrollX = TRUE))
```


```{r}
plot_stl_tuned <- stl_tuned %>%
  autoplot()

ggplotly(plot_stl_tuned) %>% layout(width = 700, height = 700, 
                      plot_bgcolor="#edf2f7")
```

:::

The STL decomposition plot consist of four panel. The bottom four panel shows breakdown of three components of STL, namely trend, seasonality, and remainder. These components can be added together to reconstruct the data shown in the top panel. The remainder component shown in the bottom panel is what is left over when the seasonal and trend-cycle components have been subtracted from the data.



### UI design

![](images/2_Decomposition.png)

## Section 3: Time Series Forecasting

### Split data into training and testing

```{r}
# Define the split point; for example, keeping the first 80% of rows for training
split_point <- nrow(filtered_period_sstn) * 0.8

# Create the training dataset (first 80% of the data)
train_daily <- filtered_period_sstn %>% 
  slice(1:floor(split_point))

# Create the test dataset (remaining 20% of the data)
test_daily <- filtered_period_sstn %>% 
  slice((floor(split_point) + 1):n())
```

### Create and fit multiple model to tesing set

We observed that our data exhibits seasonal patterns, and hence we select the models specifically designed to handle such seasonal variations.

According to Hyndman and Athanasopoulos (Forecasting: Principles and Practice, Chapter 5.7)

```{r}
train_daily_fit <- train_daily %>%
  model(
    # naïve forecast of the seasonally adjusted data
    STLNaive = decomposition_model(stl_formula_default, NAIVE(season_adjust)),              
    
    # auto arima forecast of the seasonally adjusted data
    STLArima = decomposition_model(stl_formula_default, ARIMA(season_adjust)),

    # Exponential Smoothing forecast of the seasonally adjusted data
    STLETS = decomposition_model(stl_formula_default, ETS(season_adjust ~ season("N"))),
    
    # AUTO arima
    AUTOARIMA = ARIMA(`Mean Temperature (°C)`),    
    
    # AUTO prophet
    AUTOprophet = prophet(`Mean Temperature (°C)`),
    
    # Auto Exponential smoothing
    AUTOETS = ETS(`Mean Temperature (°C)`)
    
  )

forecast_horizon <- nrow(test_daily)

# Forecasting
train_daily_fc <- forecast(train_daily_fit, h = forecast_horizon)

# Plotting the forecasts
c <- autoplot(train_daily, `Mean Temperature (°C)`) +
  autolayer(train_daily_fc, level = NULL) +
  labs(title = "Forecast Validation for daily mean temperature of Ang Mo Kio Station",
       x = "", y = "") +
  theme_minimal() 

ggplotly(c, tooltip = c("x", "y"))
```



```{r}
d <- autoplot(test_daily, `Mean Temperature (°C)`, series = "Test Data") +
  autolayer(train_daily_fc, series = "Forecast", level = NULL) +
  labs(title = "Testing data vs Forecast",
       x = "", y = "") +
  theme_minimal()

ggplotly(d, tooltip = c("x", "y"))
```

### Testing set forcast & Accuracy Evaluation

```{r}
accuracy_metrics <- accuracy(train_daily_fc, test_daily) %>%
    arrange(.model) %>%
  select(.model, .type, RMSE, MAE, MAPE, MASE) %>%
  mutate(across(c(RMSE, MAE, MAPE, MASE), round, 2))

datatable(accuracy_metrics, 
          class= "hover",
          rownames = FALSE,
          width="100%", 
          options = list(pageLength = 10,scrollX=T))
```

### Refit to Full Dataset & Forecast Forward

```{r}
# Refit models to the full dataset
full_fit <- filtered_period_sstn %>%
  model(
    # naïve forecast of the seasonally adjusted data
    STLNaive = decomposition_model(stl_formula_default, NAIVE(season_adjust)),              
    
    # auto arima forecast of the seasonally adjusted data
    STLArima = decomposition_model(stl_formula_default, ARIMA(season_adjust)),

    # Exponential Smoothing forecast of the seasonally adjusted data
    STLETS = decomposition_model(stl_formula_default, ETS(season_adjust ~ season("N"))),
    
    # AUTO arima
    AUTOARIMA = ARIMA(`Mean Temperature (°C)`),    
    
    # AUTO prophet
    AUTOprophet = prophet(`Mean Temperature (°C)`),
    
    # Auto Exponential smoothing
    AUTOETS = ETS(`Mean Temperature (°C)`)
  )
```






```{r}
# Plotting the forecasts along with the full dataset
future_horizon <- "1 month" # Adjust this to your forecast needs
full_forecast <- forecast(full_fit, h = future_horizon)

e <- autoplot(filtered_period_sstn, `Mean Temperature (°C)`) +
  autolayer(full_forecast, series = "Forecast", level = NULL) +
  labs(title = "Future Forecast Plot for daily mean temperature of Ang Mo Kio Station",
       x = "", y = "") +
  theme_minimal()

ggplotly(e, tooltip = c("x", "y"))
```



```{r}
# Table view

full_forecast_tibble <- as_tibble(full_forecast)


col<- full_forecast_tibble %>% 
  select(.model, Date, .mean) %>% 
  rename(Forecast = .mean) %>%
  mutate(Forecast = round(Forecast, 2),
         .model = as.factor(.model))


datatable(col, 
          class= "hover", 
          rownames = FALSE, 
          filter = 'top',  # Enables filters at the top of each column
          width="100%", 
          options = list(pageLength = 5, scrollX = TRUE))

```

### UI design


![](images/3_Forecasting_1.png)

![](images/3_Forecasting_2.png)

## Reference
Hyndman, R.J., & Athanasopoulos, G. (2021) Forecasting: principles and practice, 3rd edition, OTexts: Melbourne, Australia. OTexts.com/fpp3. 
